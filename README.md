# Deterministic Lockstep Netcode Model with Determinism validation and debugging tooling 

## Overview
This repository contains the source code for the package which allows for creating games which utilize deterministic lockstep netcode model, validates determinism in such game, as well as provides debugging tooling. The repository also provides code and assets of a sample Pong game that demonstrates the usage of the package.

Tool was implemented using Unity's Data-Oriented Technology Stack (DOTS). It needs to be noted that this is a showcase of methodology rather than fully working solution which will be a matter of further development.

## Features of the package

- **Deterministic Lockstep Netcode Model:** Ensures all clients in a multiplayer game remain in sync by only sending player inputs and simulating the same game state across all clients.
- **Determinism Validation Tools:** Detects nondeterministic behavior within DOTS-based games by comparing game state hashes.
- **Debugging Tools:** Helps identify and resolve sources of nondeterminism by logging game state changes and comparing them.

## Installation

1. **Clone the Repository**:
    ```sh
    git clone https://github.com/michalooo/Thesis.git
    ```

2. **Open in Unity**:
    - Open the project in Unity 6000.0.0.b16

3. **Download necessary packages**:
    - The project already contains modified version of com.unity.entities@1.2.3
    - Download any other packages which are listed in manifest.json

## Sample Game Description
The game is a modified version of the classic Pong. Two players compete by controlling paddles to hit a ball back and forth. The game starts by spawning one ball per tick until 1000 balls are spawned. The game counts the score, and when it is over, the game stops, waits for 5 seconds, and then returns to the menu.

## Sample Game Systems Overview

Those are the systems that were implemented for the sake of the sample game showcasing package usage:

1. **PongBallBounceSystem**: Detects if the ball hits the wall or a player and changes the velocity component to bounce it.
2. **PongBallDestructionSystem**: Destroys the ball entity if it crosses the left or right border and adds a point to the respective player.
3. **PongBallMovementSystem**: Moves balls according to their velocity component.
4. **PongBallSpawnerSystem**: Spawns one ball per tick with a random velocity (based on a seed generated by the server).
5. **PongMenuHandler**: MonoBehaviour that handles all buttons and menu logic.
6. **PongPlayerSpawnerSystem**: Spawns players if the connection entity lacks the PlayerSpawned component.
7. **PlayerMovementSystem**: Moves players based on data stored in PlayerInputDataToUse.
8. **InputGatherSystem**: Gathers keyboard presses and assigns values to PongInputs.
9. **UIHandler**: Manages the in-game score display.
10. **PongInputs**: Singleton component that stores player inputs for the local player.

## Lockstep Model Important Components
This implementation demonstrates a basic deterministic lockstep netcode model with added forced input latency. Important concepts are:

- **ClientBehaviour**: Handles incoming RPCs from the server.
- **ServerBehaviour**: Manages connections and incoming RPCs from clients, validates hashes, and sends packets back.
- **DeterministicSimulationSystemGroup**: System group that runs game state-affecting systems at a given FPS rate.
- **PlayerInputSendSystem**: Sends inputs to the server at the end of the DeterministicSimulationSystemGroup.
- **DeterministicSimulationTime**: Singleton component holding simulation-related variables.

## Client and Server Modes
### Server Modes
- **None**: Initial mode, no actions are being executed.
- **Disconnect**: If this mode will be set, all clients will be disconnected.
- **RunDeterministicSimulation**: If this mode will be set, the server sends aproperiate messages to all clients to load the game and starts the game after clients confirm readiness.
- **ListenForConnections**: If this mode is set, the server will listen for connections which number is restricted by allowedConnections parameter on DeterministicSettings.

### Client Modes
- **None**: Initial mode, no actions are being executed.
- **Desync**: This mode is being set by the package when nondeterminism will be detected. It's important to perform some action when this mode is set because otherwise the game will just look frozen.
- **GameFinished**: If this mode will be set, the client sends the final hash to the server and ends the game after confirmation that there was no nondeterminism.
- **LoadingGame**: This mode is being set by the package when user is supposed to load the game scene. When the game scene is loaded the mode should be chamged to ClientReady.
- **ClientReady**: If this mode will be set, client sends readiness message to the server and upon receiving message back about starting the game the simulation starts.
- **RunDeterministicSimulation**: This mode will be set automatically by the package and means that the client runs the lockstep simulation.
- **Disconnect**: If this mode will be set, the client will disconnect from the server.
- **Connect**: When this mode wil be set, the client will attemp to connect to the server with values of address and port taken from the DeterministicSettings.

## Determinism Validation and Debugging Tooling
The game includes a determinism validation system with several validation options:

1. **None**: No validation.
2. **WhitelistHashPerTick**: Validates marked components on marked entities per tick.
3. **FullStateHashPerTick**: Validates all marked components per tick.
4. **WhitelistHashPerSystem**: Validates marked components on marked entities per system.
5. **FullStateHashPerSystem**: Validates all marked components per system.

The validation system hashes game state components and sends hashes to the server for validation. If desync is detected, log files are generated for debugging.

## Log File Generation
When desync occurs, log files are generated to help identify the source of nondeterminism:

- **ServerInputRecording**: Records all player inputs and saves them in a readable format upon desync.
- **Client Logs**: Includes hashes for the last input latency ticks and logs the state of the game at the desynchronized tick.
- **System Info**: Provides information about the client machine.
- **Game Settings**: Records game settings used during the game.

## Replay functionality
It's possible to replay the game in order to use different validation method to obtain informations about a particular desync. In order to use it GameSettings and ServerInputRecording files should be placed in main NondeterminismLogs folder and **isReplayFromFile** variable in DeterministicSettings should be set to true. It allows for local simulation based on save inputs and settings.

## Package Usage
In order to use deterministic lockstep netcode model implemented by this package you can follow the implementation of the sample Pong game.
The most important aspects are that in order for it to work, several steps need to be done.

- Create Client and Server worlds on which ClientBehaviourSystem and ServerBehaviourSystem will run.
- Upon creation of those worlds modify DeterministicSettings component as needed with game parameters.
- Implement an input struct following the implementation of the one for PongSample, the struct must for now be implemented within the package and needs to contain Serialize and Deserialize methods in the same way as the PongInput struct.
- Read about Client and Server modes in the README and use them to control your simulation.
- Set all systems that are affecting simulation state to be part of DeterministicSimulationSystemGroup. This system group allows to run the systems inside with predefined in settings speed and also allows to point nondeterministic system in this group. If you have a systsem that is not affecting simulation state (for example connection handling that handles incoming information) it can be outside of the group.

The package will be a subject for modifications and improvements and this README may change or be updated.

## Future Improvement Plans

- **Automatic DeterministicID Assignment:**
  - Automate the assignment of `DeterministicID` to ensure all components are considered for validation, reducing the chance of human error.
  
- **Enhanced Logging:**
  - Implement code generation to log fields of user-created components, providing more detailed information for debugging.

- **Performance Optimization:**
  - Speed up the resimulation framework by skipping visual updates and iterating through the `DeterministicSystemGroup` as fast as possible.
