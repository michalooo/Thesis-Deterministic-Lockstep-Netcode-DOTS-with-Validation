# Deterministic Lockstep Netcode Model with Determinism validation and debugging tooling 

## Overview
This repository contains the source code for the package which allows for creating games which utilize deterministic lockstep netcode model, validates determinism in such game, as well as provides debugging tooling. The repository also provides code and assets of a sample Pong game that demonstrates the usage of the package.

Tool was implemented using Unity's Data-Oriented Technology Stack (DOTS). It needs to be noted that this is a showcase of methodology rather than fully working solution which will be a matter of further development.

## Features of the package

- **Deterministic Lockstep Netcode Model:** Ensures all clients in a multiplayer game remain in sync by only sending player inputs and simulating the same game state across all clients.
- **Determinism Validation Tools:** Detects nondeterministic behavior within DOTS-based games by comparing game state hashes.
- **Debugging Tools:** Helps identify and resolve sources of nondeterminism by logging game state changes and comparing them.

## Installation

1. **Clone the Repository**:
    ```sh
    git clone https://github.com/michalooo/Thesis.git
    ```

2. **Open in Unity**:
    - Open the project in Unity 6000.0.0.b16

3. **Download necessary packages**:
    - The project already contains modified version of com.unity.entities@1.2.3
    - Download any other packages which are listed in manifest.json

## Sample Game Description
The game is a modified version of the classic Pong. Two players compete by controlling paddles to hit a ball back and forth. The game starts by spawning one ball per tick until 1000 balls are spawned. The game counts the score, and when it is over, the game stops, waits for 5 seconds, and then returns to the menu.

## Sample Game Systems Overview

1. **PongBallBounceSystem**: Detects if the ball hits the wall or a player and changes the velocity component to bounce it.
2. **PongBallDestructionSystem**: Destroys the ball entity if it crosses the left or right border and adds a point to the respective player.
3. **PongBallMovementSystem**: Moves balls according to their velocity component.
4. **PongBallSpawnerSystem**: Spawns one ball per tick with a random velocity (based on a seed generated by the server).
5. **PongMenuHandler**: MonoBehaviour that handles all buttons and menu logic.
6. **PongPlayerSpawnerSystem**: Spawns players if the connection entity lacks the PlayerSpawned component.
7. **PlayerMovementSystem**: Moves players based on data stored in PlayerInputDataToUse.
8. **InputGatherSystem**: Gathers keyboard presses and assigns values to PongInputs.
9. **UIHandler**: Manages the in-game score display.
10. **PongInputs**: Singleton component that stores player inputs for the local player.

## Lockstep Model Overview
This implementation demonstrates a basic deterministic lockstep netcode model with added forced input latency.

- **ClientBehaviour**: Handles incoming RPCs from the server.
- **ServerBehaviour**: Manages connections and incoming RPCs from clients, validates hashes, and sends packets back.
- **DeterministicSimulationSystemGroup**: System group that runs game state-affecting systems at a given FPS rate.
- **PlayerInputSendSystem**: Sends inputs to the server at the end of the DeterministicSimulationSystemGroup.
- **DeterministicSimulationTime**: Singleton component holding simulation-related variables.

## Client and Server Modes
### Server Modes
- **None**: Initial mode, no actions executed.
- **Disconnect**: Disconnects all clients.
- **RunDeterministicSimulation**: Tells clients to load the game and starts the game after clients confirm readiness.
- **ListenForConnections**: Allows clients to connect.

### Client Modes
- **None**: Initial mode, no actions executed.
- **Desync**: Stops the simulation upon receiving a desync message.
- **GameFinished**: Sends the final hash to the server and returns to the menu after confirmation or 5 seconds.
- **LoadingGame**: Loads the game scene upon server instruction and sends readiness confirmation.
- **ClientReady**: Sends the starting hash and readiness confirmation to the server.
- **RunDeterministicSimulation**: Starts the simulation upon server confirmation.
- **Disconnect**: Disconnects from the server.
- **Connect**: Connects to the server.

## Determinism Validation and Debugging Tooling
The game includes a determinism validation system with several validation options:

1. **None**: No validation.
2. **WhitelistHashPerTick**: Validates marked components on marked entities per tick.
3. **FullStateHashPerTick**: Validates all marked components per tick.
4. **WhitelistHashPerSystem**: Validates marked components on marked entities per system.
5. **FullStateHashPerSystem**: Validates all marked components per system.

The validation system hashes game state components and sends hashes to the server for validation. If desync is detected, log files are generated for debugging.

## Log File Generation
When desync occurs, log files are generated to help identify the source of nondeterminism:

- **ServerInputRecording**: Records all player inputs and saves them in a readable format upon desync.
- **Client Logs**: Includes hashes for the last input latency ticks and logs the state of the game at the desynchronized tick.
- **System Info**: Provides information about the client machine.
- **Game Settings**: Records game settings used during the game.

## Future Improvements

- **Automatic DeterministicID Assignment:**
  - Automate the assignment of `DeterministicID` to ensure all components are considered for validation, reducing the chance of human error.
  
- **Enhanced Logging:**
  - Implement code generation to log fields of user-created components, providing more detailed information for debugging.

- **Performance Optimization:**
  - Speed up the resimulation framework by skipping visual updates and iterating through the `DeterministicSystemGroup` as fast as possible.
