using System;
using Unity.Collections;
using Unity.Entities;
using UnityEngine;

namespace DeterministicLockstep
{
    /// <summary>
    /// Hash calculation options for the deterministic simulation.
    /// </summary>
    public enum DeterminismHashCalculationOption
    {
        /// <summary>
        /// This is the default option which should also be used in production. It means that the component which were marked for validation will be hashed only if they are
        /// part of the entity which was marked for validation with the EnsureDeterministicBehaviour component.
        /// Validation will be performed on per tick basis.
        /// </summary>
        WhiteListHashPerTick,
        
        /// <summary>
        /// This option will hash the components marked for validation only if they are part of the entity which was marked for validation with the EnsureDeterministicBehaviour component.
        /// Validation will be performed on per system basis.
        /// </summary>
        WhitelistHashPerSystem,
        
        /// <summary>
        /// This option will hash all the components marked for validation on per tick basis.
        /// </summary>
        FullStateHashPerTick,
        
        /// <summary>
        /// This option will hash all the components marked for validation on per system basis.
        /// </summary>
        FullStateHashPerSystem,
        
        /// <summary>
        /// This option will not hash any components.
        /// </summary>
        None
    }
    
    /// <summary>
    /// Component which holds game simulation settings. It should be created in the scene to set the simulation settings.
    /// </summary>
    [Serializable]
    public struct DeterministicSettings : IComponentData
    {
        /// <summary>
        /// What should be the value of the forced input latency. This is used to compensate for the latency between the server and the client. Default value is 9 ticks which will result in 150ms of fixed latency.
        /// </summary>
        public int ticksOfForcedInputLatency;
        
        /// <summary>
        /// How many connections/players are allowed per game. Default value is 2.
        /// </summary>
        public int allowedConnectionsPerGame;
        
        /// <summary>
        /// How many ticks per second should the simulation run at. Default value is 60.
        /// </summary>
        public int simulationTickRate;
        
        /// <summary>
        /// What should be the hash calculation option for the simulation. Default value is WhiteListHashPerTick.
        /// </summary>
        public DeterminismHashCalculationOption hashCalculationOption;
        
        /// <summary>
        /// Should the game try to replay the simulation from a file. Default value is false. If set to true, remember to ensure that the file is present in the NonDeterminismLogs folder.
        /// </summary>
        public bool isReplayFromFile;
        
        /// <summary>
        /// Random seed for the simulation generated by the server before start of the game
        /// </summary>
        public uint randomSeed;
        
        /// <summary>
        /// If isReplayFromFile is set to true, this value will be set from the file to mark which tick was nondeterministic. This is needed since during replay there is no validation performed
        /// </summary>
        public int nonDeterministicTickDuringReplay;
        
        /// <summary>
        /// Server address for the game. Default value is the local address of 127.0.0.1.
        /// </summary>
        public FixedString32Bytes _serverAddress;
        
        /// <summary>
        /// Server port for the game. Default value is 7979.
        /// </summary>
        public int _serverPort;

        /// <summary>
        /// Bool signifying if the game simulation is running
        /// </summary>
        public bool isInGame;
    }
    
    public class DeterministicSettingsAuthoring : MonoBehaviour
    {
        [Tooltip("How many ticks per second should the simulation run at. Default value is 60.")]
        public int simulationTickRate = 60;
        [Tooltip("How many connections/players are allowed per game. Default value is 2.")]
        public int allowedConnectionsPerGame = 2;
        [Tooltip("What should be the value of the forced input latency. This is used to compensate for the latency between the server and the client. Default value is 9 ticks which will result in 150ms of fixed latency.")]
        public int ticksOfForcedInputLatency = 9;
        [Tooltip("Server port for the game. Default value is 7979.")]
        public int serverPort = 7979;
        [Tooltip("Server address for the game. Default value is the local address of 127.0.0.1.")]
        public string serverAddress = "127.0.0.1";
        [Tooltip("What should be the hash calculation option for the simulation. Default value is WhiteListHashPerTick.")]
        public DeterminismHashCalculationOption hashCalculationOption = DeterminismHashCalculationOption.WhiteListHashPerTick;
        [Tooltip("Should the game try to replay the simulation from a file. Default value is false. If set to true, remember to ensure that the file is present in the NonDeterminismLogs folder.")]
        public bool isReplayFromFile;
        
        class SettingBaker : Baker<DeterministicSettingsAuthoring>
        {
            public override void Bake(DeterministicSettingsAuthoring authoring)
            {
                var component = default(DeterministicSettings);
                component.ticksOfForcedInputLatency = authoring.ticksOfForcedInputLatency;
                component.allowedConnectionsPerGame = authoring.allowedConnectionsPerGame;
                component.simulationTickRate = authoring.simulationTickRate;
                component.hashCalculationOption = authoring.hashCalculationOption;
                component._serverPort = authoring.serverPort;
                component._serverAddress = authoring.serverAddress;
                component.isReplayFromFile = authoring.isReplayFromFile;
                component.isInGame = false;
                var entity = GetEntity(TransformUsageFlags.Dynamic);
                
                AddComponent(entity, component);
            }
        }
        
    }
}