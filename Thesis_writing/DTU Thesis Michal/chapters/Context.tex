\chapter{Context}

% Starting with summarizing and then explanation of those concepts
To fully understand the ideas behind this thesis and results which can be achieved we need to delve deeper into two key areas: \textbf{DOTS} and \textbf{GGPO}. DOTS encompasses a spectrum of concepts ranging from games and game engines to performance and scalability issues, along with the principles of Data-Oriented Design (DOD). On the other hand, understanding GGPO consist of familiarity with various types of netcodes and a comprehensive grasp of what GGPO specifically is. This thorough exploration will provide the foundation necessary for comprehending the following implementation and its implications.\newline

% Introduction of gaming in general and why its worth researching
We will start with broad introduction to gaming and it's ever-evolving environment which stands as the core of this thesis and which continuously adapts alongside technological progressions and shifting player preferences. Originating from humble beginnings with arcade machines, gaming has transformed into the extended virtual worlds of today, spanning diverse platforms and genres. The gaming industry has transitioned into a formidable cultural and economic force, surpassing its conventional perception as a solely form of entertainment. Instead, it has emerged as an influential medium in art, education, and social interaction. Consequently, the necessity to research and innovate within the gaming domain extends beyond conventional boundaries, encompassing diverse fields of study and application.\newline

% Introduction of multiplayer games and lag+cpu usage (the problem)
Within this environment, multiplayer experiences stand out as among the most complicated to develop, requiring a blend of techniques to seamlessly synchronize real-time interactions among players. Unlike single-player or local multiplayer games, where actions are confined to a single system, the complexity escalates with multiple players, amount of events happening in the scene at once, varied network conditions, and the inherent uncertainties of data transmission. As players expect immersive and uninterrupted gaming experiences, especially in scenarios with numerous entities seamlessly interconnected globally, two primary challenges emerge: CPU processing and network latency. The first one encompasses problems related to handling a lot of entities at the same time in bigger and bigger game worlds which ideally should also run on devices with not top hardware, when also in need to apply remote changes of other players and occasionally having to simulate several frames in the timespan of one to catch up with the game state. The other issue of latency which is the delay encountered in transmitting data over the internet and delivering it seemlesly on time, influenced by factors such as geographical distance, network congestion, and computational capabilities which can hinder even the best in other aspects games. This latency and computational load can impede players from fully enjoying expansive games, disrupting gameplay flow and diminishing overall enjoyment, underscoring the critical need for effective strategies to mitigate latency especially in combination with games with high CPU usage.\newline

% Introduction of netcode strategies
When understanding the general problem we will explore first the netcode itself and its means to mitigate network latency. Before the first appearance of rollback netcode solutions in 1996 used by GGPO, online gaming predominantly relied on delay-based systems. These systems aimed for perfect synchronization between players, requiring both parties to wait for each other's inputs before advancing the game to the next frame. Unfortunately, this often led to frustrating freezes and missed inputs due to network challenges. The deeper explanation of how it works can be find here: \cite{Delaybased_rollback_explanation}.

% Introduction of rollback netcode
In contrast, rollback netcode especially in combination with and player prediction revolutionized online gaming with its approach, addressing the challenges of latency in fast-paced games where player reaction windows can be as narrow as 100 milliseconds (With the round trip time of many network connections stretching into 200-500 ms of latency). Rollback netcode attempts to remedy this with speculative execution: it attempts to predict remote inputs (when latency prevent them to arrive on time) based on prior inputs and roll back and replay the simulation only when necessary. This allows games to continue simulation as if the game were entirely local. Rollback netcode ensures that players experience minimal disruptions (players only notice the network latency if the predictions are wrong), making for a much smoother online experience, particularly crucial in fast-paced competitive genres like fighting games or real-time strategy (RTS) titles, where split-second reactions can determine victory or defeat. The summary of it can be find here: \cite{Rollback_overview}.\newline

% Introduction of GGPO
At the forefront of networking advancements stands GGPO (Good Game Peace Out), a cornerstone concept in this thesis. Introduced in late 2006, GGPO revolutionized networking frameworks by pioneering rollback netcode alongside lockstep and player prediction. The GGPO networking SDK was crafted to seamlessly integrate rollback networking into both new and existing games. Notably, in 2019, the framework transitioned to an MIT license, enhancing accessibility for a broader spectrum of developers. Despite its inception over a decade ago, GGPO maintains its relevance in online gaming infrastructure, with numerous titles still leveraging its capabilities to deliver superior online experiences, as detailed on their official website \cite{GGPO_page}. %maybe not detailed

The term "rollback networking" encompasses any form of data rollback and resimulation. Both GGPO and Unity's "Network for Entities" models employ rollback and resimulation, making them both "rollback networking" architectures. However, the distinctions lie in how they synchronize and replicate entities.

In this thesis, GGPO's architecture/model will be adopted due to its deterministic nature and lockstep functionality, enabling:

\begin{itemize}
    \item Efficient replication of inputs, resulting in minimal bandwidth consumption.
    \item Seamless synchronization of a vast number of entities.
    \item Development of gameplay code with reduced concerns regarding latency or netcode intricacies.
    \item Implementation of anti-cheat measures in a "peer-to-peer" or relay environment, without the necessity for costly dedicated game servers.
    \item Leveraging the "rollback and resimulation" feature to mitigate latency inherent in lockstep architectures.
\end{itemize}

Furthermore, a custom implementation of GGPO will be integrated into the thesis, offering enhanced flexibility and potentially simplified implementation. Fundamentally, GGPO augments a deterministic lockstep architecture, such as that seen in Age of Empires 2, by incorporating rollback and resimulation alongside client prediction.

Client prediction, also known as rollback and resimulation, proves beneficial in various netcode models, including "eventual consistency," "client-server," and "snapshot synchronization." Similarly, in a "deterministic lockstep," "peer-to-peer," or relay model, client prediction effectively conceals latency. Thus, GGPO provides an alternative approach to handling netcode in gaming, particularly suited for genres like RTS and fighting games.\newline

% Introduction of gaming engines
Having explained one of the core elements of this thesis, namely GGPO, we now turn our attention to a deeper exploration of DOTS. At the heart of this concept lies Unity, one of the most widely used gaming engines in the industry. A game engine serves as the fundamental framework upon which video games are constructed. It equips developers with a comprehensive suite of tools and functionalities, facilitating the efficient creation of games.

Game engines encompass a myriad of software components, spanning tasks such as rendering graphics, managing audio, simulating physics, and implementing artificial intelligence. By leveraging pre-built systems and libraries within the gaming engine, developers can expedite the development process, allowing them to focus more on designing engaging gameplay mechanics and captivating content, rather than dedicating resources to reinventing the wheel.

Moreover, gaming engines often boast cross-platform compatibility, enabling games to be deployed seamlessly across various devices and operating systems with minimal modifications. In essence, a gaming engine serves as the cornerstone of game development, empowering developers to materialize their creative visions with efficiency and flexibility.

Notable examples of gaming engines include Unity, Unreal Engine, Godot, and CryEngine, \cite{Game_engines_comparison} each offering distinctive features and capabilities. While some companies opt to develop proprietary engines tailored to their specific needs, many developers, particularly indie game developers, find it more convenient to leverage existing solutions. Hence, the integration of new techniques and systems into popular gaming engines holds significant promise, particularly for developers seeking to enhance their workflow and elevate the quality of their creations.\newline

% Introduction of UNITY
Among the array of gaming engines available, Unity stands out as one of the most prominent and versatile options in the industry. Renowned for its accessibility, Unity offers a robust feature set while remaining free to use until a certain revenue threshold is reached. This accessibility allowing developers of all levels to create captivating and immersive experiences. With Unity, developers can create games across multiple platforms, including mobile, PC, console, and AR/VR devices. Its extensive documentation make it particularly appealing to newcomers in the game development scene. Moreover, Unity boasts a vibrant community and a vast ecosystem of assets and plugins, further enhancing its appeal as a go-to choice for game development projects.\newline

% Introduction of DOD
Before going into the explanation of what DOTS exactly is, it's essential to discuss the concept of Data-Oriented Design (DOD), which addresses a longstanding challenge stemming from the disparity between CPU computation power and memory handling capabilities (as illustrated in Figure \ref{fig:cpu-memory}).

DOD represents an approach to software development that prioritizes the efficient organization and manipulation of data for optimal performance. In contrast to traditional Object-Oriented Design (OOD), which emphasizes encapsulating data and behavior within objects, DOD focuses on structuring data in a manner that maximizes locality and minimizes cache misses. This emphasis on data organization enables developers to leverage modern hardware architectures more effectively, unlocking the full potential of multi-core processors and achieving higher levels of performance and scalability.

For example, consider a scenario in game development where hundreds or even thousands of game objects need to be processed each frame. In an Object-Oriented approach, each object may encapsulate its data and behavior, resulting in scattered memory access patterns and frequent cache misses. Conversely, in a Data-Oriented approach, game objects' data is organized contiguously in memory, facilitating efficient traversal and manipulation by leveraging techniques such as data parallelism.

The benefits of DOD become particularly evident in performance-critical domains like game development, where achieving high frame rates and responsiveness is utmost important. By aligning data layout with processing requirements and minimizing memory access overhead, DOD enables developers to create more responsive and visually stunning games that fully utilize the capabilities of modern hardware. \cite{DOD_in_games}, \cite{DOD_applications_in_games}\newline

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.4]{images/CPUvsMEMORY.png}
    \caption{CPU and Memory performance difference over the years [2]}
    \label{fig:cpu-memory}
\end{figure}

% Introduction of DOTS
Finally coming to the conclusion, Data-Oriented Technology Stack (DOTS) in Unity represents a paradigm shift in game development, leveraging Data-Oriented Design (DOD) principles to maximize performance and scalability. Built upon the Entity-Component-System (ECS) architecture, DOTS decouples data and behavior, enabling developers to optimize hardware utilization and minimize overhead. This approach prioritizes efficient data organization and processing, allowing developers to harness the full potential of modern hardware architectures.

Unity DOTS which was for the first time announced in 2018 and production ready released on May 25th 2023 introduces several key components:

\begin{itemize}
    \item \textbf{ECS for Unity} --> This framework provides seasoned Unity creators with greater control and determinism, enabling the creation of more performant games through data-oriented design.
    \item \textbf{Burst Compiler} --> Burst translates IL/.NET bytecode into highly optimized native code, leveraging the industry-proven LLVM compiler infrastructure. This compiler exposes CPU intrinsics, allowing for fine-tuning of performance-critical code.
    \item \textbf{C sharp Job System} --> This system enables developers to leverage multi-core computing platforms by running parallelized code safely and efficiently. By exposing Unity's internal C++ Job System, developers can seamlessly integrate their scripts with Unity's internal processing.
\end{itemize}

Together, these components create a powerful infrastructure for game development, offering enhanced performance, scalability, and maintainability.

While there are other similar solutions available, such as Unreal Engine's ECS and CryEngine's Job System, DOTS stands out due to its tight integration with the Unity ecosystem and its focus on enabling developers to achieve optimal performance and scalability. Its relatively recent release also presents a significant opportunity for exploration and integration into game development projects. Additionally some benefits of using DOTS in games can include scalability in sense of having more calculations/interactions happening in a game and possibility of running it on smaller/worst hardware\newline


% How those can complement each other
Upon reviewing the fundamental principles behind DOTS and GGPO, it becomes evident that there exists substantial potential for their integration. DOTS stands as a promising avenue for game developers seeking to enhance performance and scalability in their projects. Concurrently, GGPO complements DOTS by seamlessly managing lag, facilitating lockstep architecture, and harnessing DOTS capabilities for rapid resimulation of multiple frames when necessary.

Moreover, there is a likelihood that the reduced CPU overhead afforded by DOTS could contribute to latency reduction, particularly in scenarios where CPU and socket inefficiencies are significant contributors to latency. However, it's important to note that direct latency reduction may not be a primary outcome of combining DOTS and GGPO. Existing implementations of GGPO are already optimized to minimize latency to the greatest extent feasible. Rather, the synergy between DOTS and GGPO offers the potential for reduced CPU consumption, thereby enabling greater scope and scale in game development projects. Additionally, the integration of DOTS and GGPO may simplify development processes, making them more accessible to a wider range of developers.


% Additional benefits in different section???

% QUESTIONS
    % 1) Confirm dates for rollback, ggpo and player prediction --> check rollback netcode/client prediction (1996), context of lockstep/ggpo (2008)
    % 2) How much do I need to explain the topic (for example network delay)
    % 3) Correct how I use citations 
    % 4) What are netcode architectures/differences --> There are only a few different types of Netcode architecture, but almost every game will have a unique implementation of one of these architectures. We're using the GGPO architecture (or model)
    % 5) We are planning to do a custom GGPO implementation